import { join, dirname, basename, relative } from 'path';
import { readdirSync, statSync, renameSync, copyFileSync, mkdirSync, existsSync, utimesSync, writeFileSync } from 'fs';
import { generateNewName } from './formatter.js';
import { detectAmbiguity, resolveAmbiguities } from '../utils/ambiguityDetector.js';
import { extractDatesFromFiles, formatMetadataDate } from '../utils/metadataExtractor.js';
import { batchAnalyzeAmbiguousFiles } from '../utils/smartAmbiguityResolver.js';

/**
 * NOTE: This file currently uses Node.js fs and path modules directly.
 * Phase 3 migration: The FileSystemAdapter pattern is available in ../adapters/
 * for future refactoring to make this code execution-context agnostic.
 * Current status: Working with Node.js, fully functional for CLI usage.
 */

/**
 * Get path depth (number of directory levels) in a cross-platform way
 * @param {string} itemPath - Path to analyze
 * @returns {number} - Number of path segments
 */
function getPathDepth(itemPath) {
  // Normalize path separators to forward slash for consistent splitting
  // This handles both Unix (/) and Windows (\) paths
  const normalized = itemPath.replace(/[\\/]+/g, '/');
  return normalized.split('/').length;
}

/**
 * Check if a filename is a system file that should be ignored
 * @param {string} filename - Filename to check
 * @returns {boolean} - True if file should be ignored
 */
function isSystemFile(filename) {
  const systemFiles = [
    '.DS_Store',
    '.localized',
    'Thumbs.db',
    'desktop.ini',
    '.Spotlight-V100',
    '.Trashes',
    '.fseventsd',
    '.TemporaryItems',
  ];

  return systemFiles.includes(filename) ||
         filename.startsWith('._') || // macOS resource forks
         filename.startsWith('.~'); // Temporary files
}

/**
 * Rename a file while preserving its timestamps (atime and mtime)
 * @param {string} oldPath - Original file path
 * @param {string} newPath - New file path
 */
function renamePreservingTimestamps(oldPath, newPath) {
  // Get original file stats
  const stats = statSync(oldPath);
  const { atime, mtime } = stats;

  // Perform the rename
  renameSync(oldPath, newPath);

  // Restore original timestamps
  utimesSync(newPath, atime, mtime);
}

/**
 * Create a revert script to undo renaming operations
 * @param {Array<Object>} results - Array of rename results
 * @param {string} targetPath - Base directory path
 * @returns {string} - Path to the created revert script
 */
function createRevertScript(results, targetPath) {
  const scriptLines = [
    '#!/bin/bash',
    '#',
    '# Revert script generated by dating tool',
    '# This script will rename files back to their original names',
    '# while preserving creation and modification timestamps',
    '#',
    `# Generated: ${new Date().toISOString()}`,
    `# Base directory: ${targetPath}`,
    '#',
    '',
    'set -e  # Exit on error',
    '',
    '# Function to rename while preserving timestamps',
    'rename_with_timestamps() {',
    '  local old_path="$1"',
    '  local new_path="$2"',
    '  ',
    '  if [ ! -e "$old_path" ]; then',
    '    echo "Warning: Source file not found: $old_path"',
    '    return 1',
    '  fi',
    '  ',
    '  if [ -e "$new_path" ]; then',
    '    echo "Warning: Target already exists: $new_path"',
    '    return 1',
    '  fi',
    '  ',
    '  # Get timestamps (cross-platform: macOS, Linux, Git Bash)',
    '  if [[ "$OSTYPE" == "darwin"* ]]; then',
    '    # macOS (BSD stat)',
    '    local atime=$(stat -f "%a" "$old_path")',
    '    local mtime=$(stat -f "%m" "$old_path")',
    '  elif [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" ]]; then',
    '    # Windows Git Bash / Cygwin',
    '    local atime=$(stat -c "%X" "$old_path" 2>/dev/null || echo "")',
    '    local mtime=$(stat -c "%Y" "$old_path" 2>/dev/null || echo "")',
    '  else',
    '    # Linux (GNU stat)',
    '    local atime=$(stat -c "%X" "$old_path")',
    '    local mtime=$(stat -c "%Y" "$old_path")',
    '  fi',
    '  ',
    '  # Perform rename',
    '  mv "$old_path" "$new_path"',
    '  ',
    '  # Restore timestamps (best effort, cross-platform)',
    '  if [ -n "$atime" ] && [ -n "$mtime" ]; then',
    '    if [[ "$OSTYPE" == "darwin"* ]]; then',
    '      # macOS: use -r flag with epoch timestamp',
    '      touch -a -t "$(date -r "$atime" +%Y%m%d%H%M.%S 2>/dev/null)" "$new_path" 2>/dev/null || true',
    '      touch -m -t "$(date -r "$mtime" +%Y%m%d%H%M.%S 2>/dev/null)" "$new_path" 2>/dev/null || true',
    '    elif command -v python3 >/dev/null 2>&1; then',
    '      # Use Python for portable timestamp setting',
    '      python3 -c "import os; os.utime(\\"$new_path\\", ($atime, $mtime))" 2>/dev/null || true',
    '    elif command -v python >/dev/null 2>&1; then',
    '      python -c "import os; os.utime(\\"$new_path\\", ($atime, $mtime))" 2>/dev/null || true',
    '    else',
    '      # Fallback: try touch with date (may not work on all systems)',
    '      touch -a -d "@$atime" "$new_path" 2>/dev/null || true',
    '      touch -m -d "@$mtime" "$new_path" 2>/dev/null || true',
    '    fi',
    '  fi',
    '  ',
    '  echo "Reverted: $old_path -> $new_path"',
    '}',
    '',
    'echo "Starting revert process..."',
    'echo ""',
    '',
  ];

  // Add rename commands for each successful operation
  let count = 0;
  results.forEach((result) => {
    if (result.success && !result.error && result.oldName !== result.newName) {
      // Calculate relative paths from targetPath to support subdirectories
      const oldRelPath = relative(targetPath, result.oldPath);
      const newRelPath = relative(targetPath, result.newPath);

      scriptLines.push(`# Revert: ${newRelPath} -> ${oldRelPath}`);
      scriptLines.push(`rename_with_timestamps "${newRelPath}" "${oldRelPath}"`);
      scriptLines.push('');
      count++;
    }
  });

  scriptLines.push('echo ""');
  scriptLines.push(`echo "Revert completed: ${count} file(s) restored"`);
  scriptLines.push('echo "Timestamps preserved"');

  // Write the script
  const scriptPath = join(targetPath, 'revert.sh');
  const scriptContent = scriptLines.join('\n');
  writeFileSync(scriptPath, scriptContent, { mode: 0o755 });

  return scriptPath;
}

/**
 * Process a file or directory path and return results without ambiguity handling
 * Used for both files and directories, supports recursive processing
 * @param {string} path - Path to file or directory to process
 * @param {Object} options - Configuration options
 * @param {string} [options.format='yyyy-mm-dd hh.MM.ss'] - Date format template
 * @param {boolean} [options.dryRun=true] - If true, simulate without actual changes
 * @param {boolean} [options.execute=false] - If true, perform actual operations
 * @param {boolean} [options.copy=false] - If true, copy instead of rename
 * @param {string} [options.resolution] - Ambiguity resolution ('dmy', 'mdy', or 'skip')
 * @returns {Array<Object>} - Array of result objects with oldName, newName, oldPath, newPath
 */
export function processPath(path, options = {}) {
  const { format, dryRun = false, method, dateFormat, timeShiftMs } = options;
  const name = basename(path);

  // Prepare parsing options
  const parsingOptions = {};
  if (method) {
    parsingOptions.method = method;
  }
  if (dateFormat) {
    parsingOptions.dateFormat = dateFormat;
  }
  if (timeShiftMs) {
    parsingOptions.timeShiftMs = timeShiftMs;
  }

  const newName = generateNewName(name, format, parsingOptions);

  if (!newName || newName === name) {
    return { success: false, oldPath: path, newPath: path, error: 'No timestamp found or no change needed' };
  }

  const result = {
    success: false,
    oldPath: path,
    newPath: join(dirname(path), newName),
    oldName: name,
    newName: newName,
    error: null,
  };

  // If not dry-run, perform the rename
  if (!dryRun) {
    try {
      // Check if target already exists
      if (existsSync(result.newPath)) {
        result.error = 'Target already exists';
        return result;
      }

      renamePreservingTimestamps(result.oldPath, result.newPath);
      result.success = true;
    } catch (error) {
      result.error = error.message;
    }
  } else {
    result.success = true; // Dry-run is always successful
  }

  return result;
}

/**
 * Process a single file or directory (internal function)
 * @param {string} itemPath - Path to file or directory
 * @param {Object} options - Options
 * @param {string|null} targetDir - Target directory for copy mode (null for rename mode)
 * @param {string|null} basePath - Base path to preserve relative structure in copy mode
 * @returns {Object|null} - Result object with oldName, newName, error, or null if no change
 */
function processItemBase(itemPath, options, targetDir = null, basePath = null) {
  const { format, dryRun, execute, resolution, method, timeShiftMs, cachedNewName, copyFlat } = options;
  const name = basename(itemPath);

  // Use cached newName if available (performance optimization)
  // BUT: Don't use cache if parsing overrides are present that might differ from cache:
  // - resolution: cache computed with default date order (dmy)
  // - method: cache computed with default detection method (auto)
  // Note: timeShiftMs is OK - cache is built with shift already applied in discoverItems
  let newName = (cachedNewName && !resolution && !method) ? cachedNewName : null;

  if (!newName) {
    // Prepare parsing options based on ambiguity resolution and method
    const parsingOptions = {};
    if (resolution && resolution !== 'skip') {
      parsingOptions.dateFormat = resolution; // 'dmy' or 'mdy'
    }
    if (method) {
      parsingOptions.method = method; // 'heuristic', 'regex', or 'auto'
    }
    if (timeShiftMs) {
      parsingOptions.timeShiftMs = timeShiftMs;
    }

    newName = generateNewName(name, format, parsingOptions);
  }

  if (!newName || newName === name) {
    return null; // No change needed
  }

  // Determine the new path based on mode (rename or copy)
  let newPath;
  if (targetDir) {
    // Copy mode: preserve subdirectory structure unless copyFlat is true
    if (copyFlat) {
      // Flat mode: all files go to root of _c
      newPath = join(targetDir, newName);
    } else {
      // Preserve structure: keep relative path from basePath
      const relativeDir = basePath ? dirname(relative(basePath, itemPath)) : '';
      newPath = relativeDir && relativeDir !== '.'
        ? join(targetDir, relativeDir, newName)
        : join(targetDir, newName);
    }
  } else {
    // Rename mode: same directory
    newPath = join(dirname(itemPath), newName);
  }

  const result = {
    oldName: name,
    newName: newName,
    oldPath: itemPath,
    newPath: newPath,
    error: null,
    success: false, // Default to false, will be set to true on success
  };

  // If execute mode, perform the operation
  if (execute && !dryRun) {
    try {
      // Check if target already exists
      if (existsSync(result.newPath)) {
        result.error = 'Target already exists';
        return result;
      }

      if (targetDir) {
        // Copy mode
        copyRecursive(result.oldPath, result.newPath);
      } else {
        // Rename mode
        renamePreservingTimestamps(result.oldPath, result.newPath);
      }
      result.success = true;
    } catch (error) {
      result.error = error.message;
      result.success = false;
    }
  } else {
    result.success = true; // Dry-run is always successful
  }

  return result;
}

/**
 * Process a single file or directory in rename mode
 * @param {string} path - Path to file or directory
 * @param {Object} options - Options
 * @returns {Object|null} - Result object or null if no change
 */
function processItem(path, options) {
  return processItemBase(path, options, null);
}

/**
 * Copy a file or directory recursively while preserving timestamps
 * @param {string} source - Source path
 * @param {string} destination - Destination path
 */
function copyRecursive(source, destination) {
  const stats = statSync(source);

  if (stats.isDirectory()) {
    // Create destination directory
    if (!existsSync(destination)) {
      mkdirSync(destination, { recursive: true });
    }

    // Copy all items inside
    const items = readdirSync(source);
    items.forEach((item) => {
      copyRecursive(join(source, item), join(destination, item));
    });

    // Restore directory timestamps
    utimesSync(destination, stats.atime, stats.mtime);
  } else {
    // Ensure parent directory exists for file copy
    const parentDir = dirname(destination);
    if (!existsSync(parentDir)) {
      mkdirSync(parentDir, { recursive: true });
    }

    // Copy file
    copyFileSync(source, destination);

    // Restore file timestamps (atime and mtime)
    utimesSync(destination, stats.atime, stats.mtime);
  }
}

/**
 * Process a single file or directory with copy mode
 * @param {string} path - Path to file or directory
 * @param {string} timedDir - Path to timed directory
 * @param {string} basePath - Base path to preserve relative structure
 * @param {Object} options - Options
 * @returns {Object|null} - Result object or null if no change
 */
function processItemWithCopy(path, timedDir, basePath, options) {
  return processItemBase(path, options, timedDir, basePath);
}

/**
 * Recursively find all files and directories with timestamps
 * @param {string} dirPath - Directory path
 * @param {string} format - Target format
 * @param {Object} parsingOptions - Options for timestamp parsing
 * @param {Array<string>} includeExt - Extensions/types to include (use 'dir' keyword for directories)
 * @param {Array<string>} excludeExt - Extensions/types to exclude (use 'dir' keyword for directories)
 * @param {Array<string>} excludeDir - DEPRECATED: Use excludeExt with 'dir' keyword instead
 * @param {number} maxDepth - Maximum recursion depth (Infinity = unlimited)
 * @param {number} currentDepth - Current recursion depth (internal)
 * @returns {Object} - { toRename: Array<{path, newName}>, alreadyFormatted: Array<string>, withoutTimestamp: Array<string> }
 */
function findItemsWithTimestamps(dirPath, format = 'yyyy-mm-dd hh.MM.ss', parsingOptions = {}, includeExt = [], excludeExt = [], excludeDir = [], maxDepth = Infinity, currentDepth = 1) {
  const toRename = [];
  const alreadyFormatted = [];
  const withoutTimestamp = [];
  const items = readdirSync(dirPath);

  // Check if 'dir' keyword is present in filters
  const includeDirectories = includeExt.includes('dir');
  const excludeDirectories = excludeExt.includes('dir');

  // Filter out 'dir' keyword to get actual extensions
  const includeExtFiltered = includeExt.filter(ext => ext !== 'dir');
  const excludeExtFiltered = excludeExt.filter(ext => ext !== 'dir');

  items.forEach((item) => {
    // Skip system files
    if (isSystemFile(item)) {
      return;
    }

    const fullPath = join(dirPath, item);
    const stats = statSync(fullPath);

    // Apply filters for files
    if (stats.isFile()) {
      const ext = item.split('.').pop().toLowerCase();

      // Check exclude list first (extensions)
      if (excludeExtFiltered.length > 0 && excludeExtFiltered.includes(ext)) {
        return;
      }

      // Check include list (if specified, extensions only)
      // If includeExt has 'dir' only (no extensions), skip all files
      if (includeExt.length > 0) {
        if (includeExtFiltered.length === 0 && includeDirectories) {
          // Only 'dir' is included, skip files
          return;
        } else if (includeExtFiltered.length > 0 && !includeExtFiltered.includes(ext)) {
          // Has extensions filter, but this file doesn't match
          return;
        }
      }
    }

    // Apply filters for directories
    if (stats.isDirectory()) {
      // Skip '_c' folder used for copy mode
      if (item === '_c') {
        return;
      }

      // If 'dir' is in exclude list, skip all directories
      if (excludeDirectories) {
        return;
      }

      // Check if directory name is in exclude list (legacy support)
      if (excludeDir.length > 0 && excludeDir.includes(item)) {
        return;
      }

      // If includeExt explicitly asks only for directories (i.e. only 'dir' keyword),
      // keep directories; otherwise always traverse directories so files inside
      // subdirectories can be matched against extension filters.
      // (Previously directories were skipped when includeExt was present, which
      // prevented recursive searching for matching files.)
    }

    // Check if name contains a timestamp
    const newName = generateNewName(item, format, parsingOptions);
    if (newName) {
      if (newName !== item) {
        // Store both path and pre-calculated newName
        toRename.push({ path: fullPath, newName, oldName: item });
      } else {
        alreadyFormatted.push(fullPath);
      }
    } else if (stats.isFile()) {
      // File without timestamp in name (directories are skipped)
      withoutTimestamp.push(fullPath);
    }

    // Recursively search directories if we haven't reached max depth
    if (stats.isDirectory() && currentDepth < maxDepth) {
      const subResults = findItemsWithTimestamps(fullPath, format, parsingOptions, includeExt, excludeExt, excludeDir, maxDepth, currentDepth + 1);
      toRename.push(...subResults.toRename);
      alreadyFormatted.push(...subResults.alreadyFormatted);
      withoutTimestamp.push(...subResults.withoutTimestamp);
    }
  });

  return { toRename, alreadyFormatted, withoutTimestamp };
}

/**
 * Discover all items (files/directories) to process
 * @param {string} targetPath - Path to analyze
 * @param {string} format - Target format
 * @param {Object} parsingOptions - Options for timestamp parsing
 * @param {Array<string>} includeExt - Extensions/types to include (use 'dir' keyword for directories)
 * @param {Array<string>} excludeExt - Extensions/types to exclude (use 'dir' keyword for directories)
 * @param {Array<string>} excludeDir - DEPRECATED: Use excludeExt with 'dir' keyword instead
 * @param {number} maxDepth - Maximum recursion depth
 * @returns {Object} - { toRename: Array<{path, newName, oldName}>, alreadyFormatted: Array<string>, withoutTimestamp: Array<string> }
 */
function discoverItems(targetPath, format = 'yyyy-mm-dd hh.MM.ss', parsingOptions = {}, includeExt = [], excludeExt = [], excludeDir = [], maxDepth = Infinity) {
  const stats = statSync(targetPath);

  if (stats.isDirectory()) {
    return findItemsWithTimestamps(targetPath, format, parsingOptions, includeExt, excludeExt, excludeDir, maxDepth);
  }

  // Single file - check extension filter
  const name = basename(targetPath);
  const ext = name.split('.').pop().toLowerCase();

  // Check exclude list first
  if (excludeExt.length > 0 && excludeExt.includes(ext)) {
    return { toRename: [], alreadyFormatted: [], withoutTimestamp: [] };
  }

  // Check include list (if specified)
  if (includeExt.length > 0 && !includeExt.includes(ext)) {
    return { toRename: [], alreadyFormatted: [], withoutTimestamp: [] };
  }

  const newName = generateNewName(name, format, parsingOptions);

  if (newName) {
    if (newName !== name) {
      return { toRename: [{ path: targetPath, newName, oldName: name }], alreadyFormatted: [], withoutTimestamp: [] };
    }
    return { toRename: [], alreadyFormatted: [targetPath], withoutTimestamp: [] };
  }

  return { toRename: [], alreadyFormatted: [], withoutTimestamp: [targetPath] };
}

/**
 * Group items by ambiguity status
 * @param {Array<{path, newName, oldName}>} items - Array of item objects
 * @returns {Object} - { ambiguous: Array, unambiguous: Array }
 */
function groupByAmbiguity(items) {
  const ambiguous = [];
  const unambiguous = [];

  items.forEach((item) => {
    const name = item.oldName || basename(item.path || item);
    const ambiguity = detectAmbiguity(name);

    if (ambiguity) {
      ambiguous.push({
        path: item.path || item,
        name,
        ambiguity,
        cachedNewName: item.newName // Preserve cached newName
      });
    } else {
      unambiguous.push(item);
    }
  });

  return { ambiguous, unambiguous };
}

/**
 * Resolve all ambiguities interactively if needed
 * @param {Array<Object>} ambiguousFiles - Array of files with ambiguities
 * @param {boolean} dryRun - Dry run mode
 * @param {Object} presetResolutions - Preset ambiguity resolutions
 * @returns {Promise<Map>} - Map of filename -> resolution
 */
async function resolveAllAmbiguities(ambiguousFiles, presetResolutions = {}) {
  if (ambiguousFiles.length === 0) {
    return new Map();
  }

  console.log(`\n⚠️  Found ${ambiguousFiles.length} file(s) with ambiguous date formats.\n`);

  const filenames = ambiguousFiles.map((f) => f.name);
  return await resolveAmbiguities(filenames, presetResolutions);
}

/**
 * Process items in copy mode
 * @param {Array<{path, newName, oldName}>} items - Items to process
 * @param {string} targetPath - Base path
 * @param {Map} resolutions - Ambiguity resolutions
 * @param {Object} options - Processing options
 * @returns {Array<Object>} - Processing results
 */
function processItemsInCopyMode(items, targetPath, resolutions, options) {
  const { format, dryRun, execute, timeShiftMs, copyFlat } = options;
  const results = [];
  const timedDir = join(targetPath, '_c');

  // Sort by depth (deeper first) to avoid renaming parent before children
  const sortedItems = items.slice().sort((a, b) => {
    const pathA = getPathDepth(a.path || a);
    const pathB = getPathDepth(b.path || b);
    return pathB - pathA;
  });

  sortedItems.forEach((item) => {
    const itemPath = item.path || item;
    const name = item.oldName || basename(itemPath);
    const resolution = resolutions.get(name);

    if (resolution === 'skip') {
      return;
    }

    const result = processItemWithCopy(itemPath, timedDir, targetPath, {
      format,
      dryRun,
      execute,
      resolution,
      timeShiftMs,
      copyFlat,
      cachedNewName: item.newName, // Pass cached newName for optimization
    });

    if (result) {
      results.push(result);
    }
  });

  return results;
}

/**
 * Process items in rename mode
 * @param {Array<{path, newName, oldName}>} items - Items to process
 * @param {Map} resolutions - Ambiguity resolutions
 * @param {Object} options - Processing options
 * @returns {Array<Object>} - Processing results
 */
function processItemsInRenameMode(items, resolutions, options) {
  const { format, dryRun, execute, timeShiftMs } = options;
  const results = [];

  // Sort by depth (deeper first) to avoid renaming parent before children
  const sortedItems = items.slice().sort((a, b) => {
    const pathA = getPathDepth(a.path || a);
    const pathB = getPathDepth(b.path || b);
    return pathB - pathA;
  });

  sortedItems.forEach((item) => {
    const itemPath = item.path || item;
    const name = item.oldName || basename(itemPath);
    const resolution = resolutions.get(name);

    if (resolution === 'skip') {
      return;
    }

    const result = processItem(itemPath, {
      format,
      dryRun,
      execute,
      resolution,
      timeShiftMs,
      cachedNewName: item.newName, // Pass cached newName for optimization
    });

    if (result) {
      results.push(result);
    }
  });

  return results;
}

/**
 * Process a single file (not a directory)
 * @param {string} filePath - File path
 * @param {Map} resolutions - Ambiguity resolutions
 * @param {Object} options - Processing options
 * @returns {Object|null} - Processing result or null
 */
function processSingleFile(filePath, resolutions, options) {
  const { format, dryRun, execute, copy, timeShiftMs } = options;
  const name = basename(filePath);
  const resolution = resolutions.get(name);

  if (resolution === 'skip') {
    return null;
  }

  if (copy) {
    const timedDir = join(dirname(filePath), '_c');
    return processItemWithCopy(filePath, timedDir, {
      format,
      dryRun,
      execute,
      resolution,
      timeShiftMs,
    });
  }

  return processItem(filePath, {
    format,
    dryRun,
    execute,
    resolution,
    timeShiftMs,
  });
}

/**
 * Generate helpful message for skipped ambiguous file
 * @param {Object} ambiguity - Ambiguity object from detectAmbiguity
 * @returns {string} - Helpful message with resolution command
 */
function generateAmbiguityMessage(ambiguity) {
  if (ambiguity.type === 'day-month-order') {
    return `Ambiguous date: ${ambiguity.pattern} - Use --resolution dd-mm-yyyy (European) or --resolution mm-dd-yyyy (US)`;
  } else if (ambiguity.type === 'two-digit-year') {
    return `Ambiguous year: ${ambiguity.pattern} - Use --resolution 2000s or --resolution 1900s`;
  }
  return 'Ambiguous date format - use --resolution or --interactive for manual resolution';
}

/**
 * Main rename function - renames files/directories based on embedded timestamps
 * Supports both rename and copy modes, with interactive ambiguity resolution
 * @param {string} targetPath - Path to file or directory to process
 * @param {Object} options - Configuration options
 * @param {string} [options.format='yyyy-mm-dd hh.MM.ss'] - Date format template
 * @param {boolean} [options.copy=false] - If true, copy instead of rename
 * @param {boolean} [options.dryRun=true] - If true, simulate without actual changes
 * @param {boolean} [options.execute=false] - If true, perform actual operations
 * @param {boolean} [options.interactive=false] - If true, prompt for ambiguities
 * @param {Array<string>} [options.includeExt=[]] - Extensions to include
 * @param {Array<string>} [options.excludeExt=[]] - Extensions to exclude
 * @param {Array<string>} [options.excludeDir=[]] - Directory names to exclude
 * @param {number} [options.depth=Infinity] - Maximum recursion depth
 * @returns {Promise<Object>} - Object with { results: Array<Object>, alreadyFormatted: number, noTimestamp: boolean, withoutTimestamp: number, skippedAmbiguous: Array<Object> }
 */
export async function rename(targetPath, options = {}) {
  const {
    format = 'yyyy-mm-dd hh.MM.ss',
    copy = false,
    copyFlat = false,
    dryRun = true,
    execute = false,
    timeShiftMs = null,
    ambiguityResolution = {},
    interactive = false,
    includeExt = [],
    excludeExt = [],
    excludeDir = [],
    depth = Infinity,
    noRevert = false,
  } = options;

  const stats = statSync(targetPath);

  // Prepare parsing options for discovery phase
  const parsingOptions = {};
  if (timeShiftMs) {
    parsingOptions.timeShiftMs = timeShiftMs;
  }

  // Step 1: Discover all items to process (with cached newName for performance)
  const discovered = discoverItems(targetPath, format, parsingOptions, includeExt, excludeExt, excludeDir, depth);
  const items = discovered.toRename;
  const alreadyFormattedCount = discovered.alreadyFormatted.length;
  const withoutTimestampCount = discovered.withoutTimestamp.length;

  // Check if no timestamps found at all
  const noTimestamp = items.length === 0 && alreadyFormattedCount === 0;

  // Step 2: Group by ambiguity status
  const { ambiguous } = groupByAmbiguity(items);

  // Step 3: Resolve ambiguities based on mode
  let resolutions = new Map();
  const skippedAmbiguous = [];
  let smartResolutions = null;

  if (interactive) {
    // Interactive mode: prompt for ambiguities
    resolutions = await resolveAllAmbiguities(ambiguous, ambiguityResolution);
  } else {
    // Non-interactive mode with smart resolution
    if (ambiguous.length > 0) {
      // Prepare file list for smart analysis
      const filesForAnalysis = ambiguous.map(item => ({
        path: item.path,
        name: item.oldName || basename(item.path || item),
      }));

      // Use smart resolver to auto-resolve high-confidence cases
      smartResolutions = batchAnalyzeAmbiguousFiles(filesForAnalysis, 80);

      // Apply smart resolutions
      for (const [name, resolution] of smartResolutions.autoResolved) {
        // Convert smart resolution format to our resolution format
        if (resolution === 'dmy' || resolution === 'mdy') {
          resolutions.set(name, resolution);
        } else if (resolution === '2000s' || resolution === '1900s') {
          resolutions.set(name, resolution);
        }
      }

      // Process remaining items
      for (const item of ambiguous) {
        const name = item.oldName || basename(item.path || item);

        // Skip if already resolved by smart resolver
        if (resolutions.has(name)) {
          continue;
        }

        let resolved = false;

        // Check if we have a preset resolution for this ambiguity type
        if (ambiguityResolution.dateFormat) {
          const dateFormat = ambiguityResolution.dateFormat === 'dd-mm-yyyy' ? 'dmy' : 'mdy';
          resolutions.set(name, dateFormat);
          resolved = true;
        } else if (ambiguityResolution.century) {
          const century = ambiguityResolution.century === '2000s' ? '2000s' : '1900s';
          resolutions.set(name, century);
          resolved = true;
        }

        // If no preset resolution and not auto-resolved, skip this file
        if (!resolved) {
          // Find the analysis for this file
          const analysis = smartResolutions.needsPrompt.find(f => f.name === name);

          skippedAmbiguous.push({
            name,
            path: item.path,
            ambiguity: item.ambiguity,
            message: generateAmbiguityMessage(item.ambiguity),
            smart: analysis?.analysis?.smart || null,
          });
          resolutions.set(name, 'skip');
        }
      }
    }
  }

  // Step 4: Process based on mode and item type
  let results = [];

  if (stats.isDirectory()) {
    if (copy) {
      results = processItemsInCopyMode(items, targetPath, resolutions, { format, dryRun, execute, timeShiftMs, copyFlat });
    } else {
      results = processItemsInRenameMode(items, resolutions, { format, dryRun, execute, timeShiftMs });
    }
  } else {
    // Single file
    const result = processSingleFile(targetPath, resolutions, { format, dryRun, execute, copy, timeShiftMs });
    if (result) {
      results = [result];
    }
  }

  // Create revert script if any files were successfully renamed (and not dry-run)
  let revertScriptPath = null;
  if (!dryRun && execute && !noRevert && results.some(r => r.success && !r.error)) {
    try {
      revertScriptPath = createRevertScript(results, stats.isDirectory() ? targetPath : dirname(targetPath));
    } catch (error) {
      console.error('Warning: Could not create revert script:', error.message);
    }
  }

  return {
    results,
    alreadyFormatted: alreadyFormattedCount,
    noTimestamp,
    withoutTimestamp: withoutTimestampCount,
    revertScriptPath,
    skippedAmbiguous,
    smartStats: smartResolutions?.stats || null,
  };
}

/**
 * Recursively find all files (not directories) without timestamps
 * @param {string} dirPath - Directory path
 * @returns {Array<string>} - Array of file paths without timestamps
 */
function findFilesWithoutTimestamps(dirPath) {
  const filesWithoutTimestamps = [];
  const items = readdirSync(dirPath);

  items.forEach((item) => {
    // Skip system files
    if (isSystemFile(item)) {
      return;
    }

    const fullPath = join(dirPath, item);
    const stats = statSync(fullPath);

    if (stats.isDirectory()) {
      // Recursively search directories
      const subFiles = findFilesWithoutTimestamps(fullPath);
      filesWithoutTimestamps.push(...subFiles);
    } else {
      // Check if file has a timestamp in name
      const newName = generateNewName(item);
      if (!newName) {
        // No timestamp found at all
        filesWithoutTimestamps.push(fullPath);
      } else {
        // Check if timestamp is incomplete (e.g., date without time)
        // If file starts with date pattern but doesn't have time, include it
        const hasDateOnly = /^\d{4}-\d{2}-\d{2}(?:\s+|_|-|$)/.test(item);
        const hasTime = /^\d{4}-\d{2}-\d{2}\s+\d{2}[.:]\d{2}[.:]\d{2}/.test(item);

        if (hasDateOnly && !hasTime) {
          // Incomplete timestamp (has date but no time)
          filesWithoutTimestamps.push(fullPath);
        }
      }
    }
  });

  return filesWithoutTimestamps;
}

/**
 * Discover files without timestamps
 * @param {string} targetPath - Path to file or directory
 * @returns {Array<string>} - Array of file paths without timestamps
 */
function discoverFilesWithoutTimestamps(targetPath) {
  const stats = statSync(targetPath);

  if (stats.isDirectory()) {
    return findFilesWithoutTimestamps(targetPath);
  }

  // Single file
  const name = basename(targetPath);
  const newName = generateNewName(name);

  if (!newName) {
    return [targetPath];
  }

  return [];
}

/**
 * Rename files using metadata (mtime, EXIF, etc.)
 * @param {string} targetPath - Path to file or directory
 * @param {Object} options - Configuration options
 * @param {string} [options.format='yyyy-mm-dd hh.MM.ss'] - Date format template
 * @param {boolean} [options.dryRun=true] - If true, simulate without actual changes
 * @param {boolean} [options.execute=false] - If true, perform actual operations
 * @param {string} [options.metadataSource='earliest'] - Metadata source preference
 * @param {Function} [options.onProgress] - Progress callback (current, total)
 * @returns {Promise<Object>} - Object with { results: Array<Object>, filesScanned: number, datesFound: number }
 */
export async function renameUsingMetadata(targetPath, options = {}) {
  const {
    format = 'yyyy-mm-dd hh.MM.ss',
    dryRun = true,
    execute = false,
    metadataSource = 'earliest',
    onProgress,
    timeShiftMs = null,
    cachedMetadata = null, // Accept pre-extracted metadata to avoid re-scanning
  } = options;

  let metadataMap;
  let allFilesWithoutTimestamps; // Store to avoid re-scanning

  // If cached metadata provided, use it directly
  if (cachedMetadata) {
    metadataMap = cachedMetadata;
    // Still need to get the list for skipped files calculation
    allFilesWithoutTimestamps = discoverFilesWithoutTimestamps(targetPath);
  } else {
    // Step 1: Find all files without timestamps
    allFilesWithoutTimestamps = discoverFilesWithoutTimestamps(targetPath);

    if (allFilesWithoutTimestamps.length === 0) {
      return {
        results: [],
        filesScanned: 0,
        datesFound: 0,
        skippedNoMetadata: [],
      };
    }

    // Step 2: Extract metadata from files with progress reporting
    metadataMap = await extractDatesFromFiles(allFilesWithoutTimestamps, {
      concurrency: 5,
      preferredSource: metadataSource,
      onProgress,
    });
  }

  // Step 3: Track files without metadata (skipped)
  // Reuse allFilesWithoutTimestamps instead of re-scanning
  const skippedNoMetadata = allFilesWithoutTimestamps
    .filter(filePath => !metadataMap.has(filePath))
    .map(filePath => {
      const ext = filePath.toLowerCase().split('.').pop();
      let reason = 'No metadata found';

      if (metadataSource === 'content') {
        // Specific message for content mode
        const imageExts = ['jpg', 'jpeg', 'png', 'tiff', 'tif', 'heic', 'heif', 'raw', 'cr2', 'nef', 'arw'];
        const audioExts = ['mp3', 'm4a', 'aac', 'ogg', 'oga', 'wav', 'wave', 'aif', 'aiff', 'aifc'];

        if (imageExts.includes(ext)) {
          reason = 'No EXIF metadata found (use -m earliest for creation time fallback)';
        } else if (audioExts.includes(ext)) {
          reason = 'No audio metadata found (ID3/M4A/etc.) (use -m earliest for creation time fallback)';
        } else {
          reason = 'No embedded metadata found (use -m earliest or -m birthtime)';
        }
      } else if (metadataSource === 'birthtime') {
        reason = 'No valid creation time (birthtime) found';
      }

      return {
        name: basename(filePath),
        path: filePath,
        reason,
      };
    });

  // Step 4: Generate new names and prepare results
  const results = [];

  for (const [filePath, metadata] of metadataMap.entries()) {
    const name = basename(filePath);
    const datePrefix = formatMetadataDate(metadata, format, timeShiftMs);
    const newName = `${datePrefix} ${name}`;
    const newPath = join(dirname(filePath), newName);

    const result = {
      oldName: name,
      newName: newName,
      oldPath: filePath,
      newPath: newPath,
      source: metadata.source,
      error: null,
    };

    // Step 4: Apply changes if in execute mode
    if (execute && !dryRun) {
      try {
        // Check if target already exists
        if (existsSync(newPath)) {
          result.error = 'Target already exists';
        } else {
          renamePreservingTimestamps(filePath, newPath);
          result.success = true;
        }
      } catch (error) {
        result.error = error.message;
      }
    } else {
      result.success = true; // Dry-run is always successful
    }

    results.push(result);
  }

  return {
    results,
    filesScanned: allFilesWithoutTimestamps.length,
    datesFound: metadataMap.size,
    skippedNoMetadata,
    metadataMap, // Return the metadata map for caching
  };
}
